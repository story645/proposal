\documentclass[../main.tex]{subfiles}

\begin{document}
\section{Prototype Implementation: Matplottoy}
\label{sec:implementation}
\begin{figure}[H]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/scatter_0.png}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/line_1.png}
    \end{subfigure}
    \caption{Scatter plot and line plot implemented using prototype artists and data models, building on Matplotlib rendering.}
    \label{fig:code_scatter_line}
\end{figure}

To prototype our model, we implemented the artist classes for the scatter and line plots shown in figure~\ref{fig:code_scatter_line} because they differ in every attribute: different visual channels \vchannel\ that composite to different marks \vmark\ with different continuities \vindex\.  We make use of the Matplotlib figure and axes artists \cite{hunterArchitectureOpenSource,hunterMatplotlib2DGraphics2007} so that we can initially focus on the data to graphic transformations. 

To generate the images in figure~\ref{fig:code_scatter_line}, we instantiate \mintinline{python}{fig, ax} artists that will contain the new \mintinline{python}{Point, Line} primitive objects we implemented based on our topology model. 

\begin{multicols*}{2}
\begin{minted}{python}
    fig, ax = plt.subplots()
    artist = Point(data, transforms)
    ax.add_artist(artist)
\end{minted}
\columnbreak
\begin{minted}{python}
    fig, ax = plt.subplots()
    artist = Line(data, transforms)
    ax.add_artist(artist)
\end{minted}
\end{multicols*}
We then add the \mintinline{python}{Point} and \mintinline{python}{Line} artists that construct the scatter and line graphics. The arguments to the artist are the data \mintinline{python}{data} that is to be plotted and the aesthetic configuration \mintinline{python}{transforms}. In general, the way in which we implement the math is described as follows:
\begin{tabular}
    \begin{table}{|l|l|l|}
        \hline
        \textbf{Math} & \texbf{Code} & \textbf{Examples} \\
        \textbf{\vartistEQ} & & \\

    \end{table}

\end{tabular}

\begin{mdframed}[roundcorner=10pt, frametitle= topology driven architecture, frametitlerule=true, frametitlebackgroundcolor=gray!10]
    \begin{description}
        \item[\textbf{\vartistEQ}] artist objects such as  \mintinline{python}{Point},  \mintinline{python}{Line}, \mintinline{python}{bar}
        \item[\textbf{\vchannel}] 
        \item[\textbf{\markd}] 
        \item[\textbf{\vtotal}] 
        \item[\textbf{\dtotal}] 
    \end{description}
\end{mdframed}
Implementing \gtotal\ and \gsection\ are out of scope for this prototype because they are part of the rendering process. We do not implement any form of \vindex\ because the scatter, line, and bar plots prototyped here directly broadcast from \dbasepoint to \gbasepoint, unlike for example an image which may need to be rotated. We implement the artists as equivalence classes \vartisteq\ because it would be impractical to implement a new artist for every aesthetic setting, such as one artist for red lines and another for green.
 
\subsection{Artist Class $\vartist^{\prime}$}
\label{sec:code_artist}
The artist is the piece of the matplotlib architecture that constructs an internal representation of the graphic that the render then uses to draw the graphic. In the prototype artist, \mintinline{python}{transform} is a dictionary of the form \mintinline{python}|{parameter:(variable, encoder)}| where parameter is a component in \vfiber, variable is a component in \dfiber,  and the \vchannel\ encoders are passed in as functions or callable objects. The data bundle \dtotal\ is passed in as a \mintinline{python}{data} object. By binding data and transforms to \vartisteq\ inside \mintinline{python}{__init__}, the \mintinline{python}{draw} method is a fully specified artist \vartist.

\begin{minted}{python}
class ArtistClass(matplotlib.artist.Artist):
    def __init__(self, data, transforms, *args, **kwargs):
        # properties that are specific to the graphic but not the channels
        self.data = data 
        self.transforms = transforms
        super().__init__(*args, **kwargs)

    def assemble(self, visual):
        # set the properties of the graphic

    def draw(self, renderer, *args, **kwargs):
        # returns K, indexed on fiber then key 
        view = self.data.view() 
        # visual channel encoding applied fiberwise 
        visual = {p: encoder(view.get(f, None)) for 
                     p, (f, encoder) in self.transforms.items()}
        self.assemble(visual)
        # pass configurations off to the renderer
        super().draw(renderer, *args, **kwargs)
\end{minted}

The data is fetched in section \dsection\ via a \mintinline{python}{view} method on the data because the input to the artist is a section on \dtotal. The return view object has a \mintinline{python}{get} method to support querying for components that are not in \dfiber\, which we exploit to support parameters in the visual fiber that are not bound to fiber components in \dfiber. The \vchannel\ functions are then applied to the data to generate the \vsection=\mintinline{python}{visual} input to \vmark. An explicit \vindex\ is not implemented since that would mean copying a single \vsection on \dbasepoint to all the associated \gbasepoint, as illustrated in figure~\ref{fig:graphic_retraction_map}, and that is unnecessary overhead for these scatter and line plots. In \vmarkd=\mintinline{python}{assemble} the artist generates instructions for the render by setting  the attributes that are related to the graphic. These are the settings that would have to be serialized in order to recreate a static version of the graphic. Although \mintinline{python}{assemble} could be implemented outside the class such that it returns an object the artist could then parse to set attributes, the attributes are directly set here to reduce indirection. The \vchannel\ functions could be evaluated in this function to avoid passing over \dbase twice but are not done so here to demonstrate the seperability of \vchannel\ and \vmarkd\. The last step in the artist function is handing itself off to the renderer. 

The \mintinline{python}{Point} artist builds on \mintinline{python}{collection} artists because collections are optimized to efficiently draw a sequence of primitive point and area marks. In this prototype, the scatter marker shape is fixed as a circle, and the only visual fiber components are x and y position, size, and the facecolor of the marker. 
\begin{minted}{python}
class Point(mcollections.Collection):
    def __init__(self, data, transforms, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.data = data
        self.transforms = transforms

    def assemble(self, visual):
        # construct geometries of the circle marks in visual coordinates
        self._paths = [mpath.Path.circle(center=(x,y), radius=s) 
                       for (x, y, s) in zip(visual['x'],visual['y'], visual['s'])] 
        # set attributes of marks, these are vectorized 
        # circles and facecolors are lists of the same size
        self.set_facecolors(visual['facecolors'])
        
    def draw(self, renderer, *args, **kwargs):
        # query data for a vertex table K
        view = self.data.view() 
        visual = {p: encoder(view.get(f, None)) for 
                     p, (f, encoder) in self.transforms.items()}
        self.assemble(visual)
        # call the renderer that will draw based on properties
        super().draw(renderer, *args, **kwargs)
   
\end{minted} 
The \mintinline{python}{view} method repackages the data as a fiber component indexed table of vertices, as described in section~\ref{sec:triangulization}; even though the \mintinline{python}{view} is fiber indexed, each vertex at an index \dbasepoint has corresponding values in section $\dsection(\dbasepoint_{i})$ such that all the data on one vertex maps to one marker. To ensure the integrity of the section, \mintinline{python}{view} must be atomic, meaning that the values cannot change after the method is called in draw until a new call in draw. This table is converted to a table of visual variables. It is then passed into \mintinline{python}{assemble}, where it is used to individually construct the vector path of each circular marker with center \texttt{(x,y)} and size \texttt{x} and set the colors of each circle. Since \mintinline{python}{view} returns a \dsection\, all these operations could be applied on a section on one \dbasepoint\ or a subset of \dbase.

The only difference between the \mintinline{python}{Point} and \mintinline{python}{Line} objects is in the \mintinline{python}{view} and \mintinline{python}{assemble} function because line has different continuity from scatter and is represented by a different type of graphical mark. 

\begin{minted}{python}
class Line(mcollections.LineCollection):
    def assemble(self, visual):
        #assemble line marks as set of segments 
        segments = [np.vstack((vx, vy)).T for vx, vy 
                    in zip(visual['x'], visual['y'])]
        self.set_segments(segments)
        self.set_color(visual['color'])
        
    def draw(self, renderer, *args, **kwargs):
        # query data source for edge table
        view = self.data.view()
        visual = {p: encoder(view.get(f, None)) for 
                     p, (f, encoder) in self.transforms.items()}
        self.assemble(visual)
        super().draw(renderer, *args, **kwargs)


\end{minted}
In the \mintinline{python}{Line} artist, \mintinline{python}{view} returns a table of edges. Each edge consists of (x,y) points sampled along the line defined by the edge and information such as the color of the edge. As with \mintinline{python}{Point}, the data is then converted into visual variables. In \mintinline{python}{assemble}, this visual representation is composed into a set of line segments and then the colors of each line segment are set. The colors are guaranteed to correspond to the correct segment because of the atomicity constraint on view. 

\subsection{Encoders \vchannel}
\label{sec:code_channels}
As mentioned above, the encoding dictionary is specified by the visual fiber component, the corresponding data fiber component, and the mapping function. The visual parameter serves as the dictionary key because the visual representation is constructed from the encoding applied to the data  $\vsection = \vchannel \circ \dsection$. For the scatter plot, the mappings for the visual fiber components $\vfiber=(x,y, facecolors, s)$ are defined as
\begin{minted}{python}
cmap =  color.Categorical({'true':'deeppink', 'false':'deepskyblue'})
transforms = {'y': ('v1', lambda x: x),       
              'x': ('v3', lambda x: x),
             'facecolors': ('v2', cmap), 
             's':(None ,lambda _: itertools.repeat(.02))}
\end{minted}
where the position \textit{(x,y)} \vchannel\ transformers are identity functions. The size \textit{s} transformer is not acting on a component of \dfiber, instead it is a \vchannel\ that returns a constant value. While size could be embedded inside the \mintinline{python}{assembly} function, it is added to the transformers to illustrate user configured visual parameters that could either be constant or mapped to a component in \dfiber. The identity and constant \vchannel\ are explicitly implemented here to demonstrate their implicit role in the visual pipeline, but they could be optimized away. More complex encoders can be implemented as callable classes, such as 
\begin{minted}{python}
class Categorical:
    def __init__(self, mapping):
        # check that the conversion is to valid colors
        assert(mcolors.is_color_like(color) for color in mapping.values())
        self._mapping = mapping

    def __call__(self, value):
        # convert value to a color
        return [mcolors.to_rgba(self._mapping[v]) for v in values]
\end{minted}

where \mintinline{python}{__init__} can validate that the output of the \vchannel\ is a valid element of the \vfiber\ component the \vchannel\ function is targeting. Creating a callable class also provides a simple way to swap out the specific (data, value) mapping without having to reimplement the validation or conversion logic. 

A test for equivariance can be implemented trivially such that it is independent of data or encoder.
\begin{minted}{python}
def test_nominal(values, encoder):
    m1 = list(zip(values, encoder(values)))
    random.shuffle(values)
    m2 = list(zip(values, encoder(values)))
    assert sorted(m1) == sorted(m2)
\end{minted}
In this example, \mintinline{python}{is_nominal} checks for equivariance of permutation group actions by applying the encoder to a set of values, shuffling values, and checking that (value, encoding) pairs remain the same. This equivariance test can be implemented as part of the artist or encoder, but for minimal overhead, the equivariant it is implemented as part of the library tests.

\subsection{Data \dtotal}
\label{sec:code_data}
The data input into the \mintinline{pythin}{Artist} will often be a wrapper class around an existing data structure, but must meet the following criteria:
\begin{enumerate}
\item specify the fiber components \dfiber\ and connectivity \dbase\
\item have a \mintinline{view} method that returns an atomic object that encapsulates \dsection\
\item the view object must have \mintinline{get} method that returns a fiber component
\end{enumerate}
To support specifying the fiber bundle, we define an optional \mintinline{python}{FiberBundle} class

\begin{minted}{python}
class FiberBundle:
    def __init__(self, base, fiber):
        """
        base:  {'tables': ['vertex', 'edge', 'face']}
        fiber: {'component name': {'type':, 'monoid':,  'range':}}
        """
        self.base = base
        self.fiber = fiber
\end{minted}

that asks the user to specify how \dbase is triangulated and the attributes of \dfiber. The \mintinline{python}{assembly} functions expect tables that match the continuity of the graphic; scatter expects a vertex table because it is discontinuous, line expects an edge table because it is 1D continuous. The fiber informs appropriate choice of \vchannel\, therefore it is a dictionary of attributes of the fiber components.  \note{I've basically stripped this out of the artists above so should I just ditch this section?}

To generate the scatter plot in figure~\ref{fig:code_scatter_line}, we fully specify a dataset with random keys and values in a section chosen at random form the corresponding fiber component. The fiberbundle \mintinline{python}{FB} is a class level attribute since all instances of \mintinline{python}{code}{VertexSimplex} come from the same fiberbundle.
\begin{minted}{python}
class VertexSimplex: #maybe change name to something else
    """Fiberbundle is consistent across all sections
    """
    FB = FiberBundle({'tables': ['vertex']},  
            {'v1': {'type': float,'monoid':'interval','range': [0,1]},
             'v2': {'type': str, 'monoid':'nominal', 'range':['true', 'false']},
             'v3': {'type': float, 'monoid':'interval', 'range':[2,3]}})

    def __init__(self, sid = 45, size=1000, max_key=10**10):
        # create random list of keys
    def tau(self, k):
        # e1 is sampled from F1, e2 from F2, etc...
        return (k, (e1, e2, e3, e4))

    def view(self):
        table = defaultdict(list)
        for k in self.keys:
            table['index'] = k
            # on each iteration, add one (name, value) pair per component
            for (name, value) in zip(self.FB.fiber.keys(), self.tau(k)[1]):
                table[name].append(value)
        return table
\end{minted}
The view method returns a dictionary where the key is a fiber component name and the value is a list of values in the fiber component. The table is built one call to \mintinline{python}{tau} at a time, guaranteeing that all the fiber component values are over the same \dbasepoint. Table has a \mintinline{python}{get} method as it is a method on Python dictionaries. In contrast, the line in \mintinline{python}{EdgeSimplex} is defined as the functions \mintinline{python}{_color,_xy} on each edge. 

\begin{minted}{python}
class EdgeSimplex: 
    # assign a class level FB attribute
    def __init__(self, num_edges=4, num_samples=1000): 
        self.keys = range(num_edge) #edge id
        # distance along edge
        self.distances = np.linspace(0,1, num_samples)
        # half generlized representation of arcs on a circle
        self.angle_samples = np.linspace(0, 2*np.pi, len(self.keys)+1)

    @staticmethod
    def _color(edge):
        colors = ['red','orange', 'green','blue']
        return colors[edge%len(colors)]

    @staticmethod
    def _xy(edge, distances, start=0, end=2*np.pi):
        # start and end are parameterizations b/c really there is 
        angles = (distances *(end-start)) + start
        return np.cos(angles), np.sin(angles)

    def tau(self, k): #will fix location on page on revision
        x, y = self._xy(k, self.distances, 
                        self.angle_samples[k], self.angle_samples[k+1]) 
        color = self._color(k) 
        return (k, (x, y, color))

    def view(self, simplex):
        table = defaultdict(list)
        for k in self.keys:
            table['index'].append(k)
            # (name, value) pair, value is [x0, ..., xn] for x, y
            for (name, value) in zip(self.FB.fiber.keys(), self.tau(k, simplex)[1]):
                table[name].append(value)
\end{minted}
Unlike scatter, the line \mintinline{python}{tau} method returns the functions on the edge evaluated on the interval [0,1]. By default these means each \mintinline{python}{tau} returns a list of 1000 x and y points and the associated color. As with scatter, \mintinline{python}{view} builds a table by calling \mintinline{python}{tau} for each \dbasepoint\. Unlike scatter, the line table is a list where each item contains a list of points. This bookkeeping of which data is on an edge is used by the \mintinline{python}{assembly} functions to bind segments to their visual properties. 

\begin{figure}[H]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/linec_1.png}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/lined_1.png}
    \end{subfigure}
    \caption{Continuous and discontinuous lines as defined by different data models, but generated with the same \vartisteq=\mintinline{python}{artist}}
    \label{fig:circle_step}
\end{figure}

The graphics in figure~\ref{fig:circle_step} are made using the \mintinline{python}{Line} artist and the \mintinline{python}{Graphline} data source

\begin{minted}{python}
class GraphLine:
    def __init__(self, FB, edge_table, vertex_table, num_samples=1000, connect=False):
        #s set args as attributes and generate distance
        if connect: # test connectivity if edges are continuous
            assert edge_table.keys() == self.FB.F.keys()
            assert is_continuous(vertex_table)

    def tau(self, k, simplex='edge'):
        # evaluates functions defined in edge table
        return(k, (self.edges[c][k](self.distances) for c in self.FB.F.keys()))

    def view(self, simplex='edge'):
        """walk the edge_vertex table to return the edge function
        """
        table = defaultdict(list)
        #sort since intervals lie along number line and are ordered pair neighbors
        for (i, (start, end)) in sorted(zip(self.ids, self.vertices), key=lambda v:v[1][0]):
            table['index'].append(i)
            # same as view for line, returns nested list
            for (name, value) in zip(self.FB.F.keys(), self.tau(i, simplex)[1]):
                table[name].append(value)
        return table
\end{minted}
where if told that the data is connected, the data source will check for that connectivity by constructing an adjacency matrix. The multicolored line is a connected graph of edges with each edge function evaluated on 1000 samples 
\begin{minted}{python}
simplex.GraphLine(FB, edge_table, vertex_table, connect=True)
\end{minted}
while the stair chart is discontinuous and only needs to be evaluated at the edges of the interval 
\begin{minted}{python}
simplex.GraphLine(FB, edge_table, vertex_table, num_samples=2, connect=False)
\end{minted}
such that one advantage of this model is it helps differentiate graphics that have different artists from graphics that have the same artist but make different assumptions about the source data. 




\subsection{Case Study: Penguins}
For this case study, we use the Palmer Penguins dataset\cite{gormanEcologicalSexualDimorphism2014, horstPalmerpenguinsPalmerArchipelago2020} since it is multivariate and has a varying number of penguins. We use a version of the data packaged as a pandas dataframe\cite{nakhaeeMcnakhaeePalmerpenguins2021, jeff_reback_2020_3715232} since that is a very commonly used Python labled data structure. The wrapper is very thin since here there is explicitly only one section.
\begin{minted}{python}
class DataFrameSection:
    def __init__(self, dataframe):
        self._tau = dataframe.iloc
        self._view = dataframe
    def view(self):
        return self._view
\end{minted}
The pandas indexer is a key valued set of discrete vertices, so there is no need to repackage for triangulation. As with the previous examples, there is no need to implement an explicit \mintinline{python}{get} method since the \mintinline{python}{dataframe} object has a get method. 

\begin{figure}[H]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/bar_v.png}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/bar_h.png}
    \end{subfigure}
    \caption{Frequency of Penguin types visualized as discrete bars. }
    \label{fig:code_bar_simple}
\end{figure}
The bar charts in figure~\ref{fig:code_bar_simple} are generated with a \mintinline{python}{Bar} artist. The have the same required \vfiber\ components of (position, length). In \mintinline{pyton}{__init__} of \mintinline{python}{Bar} an additional parameter is set, \texttt{orientation} which only applies holistically to the graphic and never to individual data parameters. Explicitly differentiate between parameters in \vtotal\ and ones that are only in \vmarkd\ is another way this model allows for cleaner separation of roles in the code. 

\begin{minted}{python}
class Bar(mcollections.Collection):
    def __init__(self, data, transforms, *args, **kwargs):
        # parameter of the graphic
        self.orientation = kwargs.pop('orientation', 'v')

        super().__init__(*args, **kwargs)
        self.data = data
        self.transforms = transforms

    @staticmethod    
    def _make_bars(orientation, position, width, floor, length):
        if orientation in {'vertical', 'v'}:
            xval, xoff, yval, yoff = position, width, floor, length
        elif orientation in {'horizontal', 'h'}:
            xval, xoff, yval, yoff = floor, length, position, width
        return [[(x, y), (x, y+yo), (x+xo, y+yo), (x+xo, y), (x, y)] 
                for (x, xo, y, yo) in zip(xval, xoff, yval, yoff)]

    
    def assemble(self, visual):
        #set some defaults
        visual['width'] = visual.get('width', itertools.repeat(0.8))
        visual['floor'] = visual.get('floor', itertools.repeat(0))
        visual['facecolors'] = visual.get('facecolors', 'C0')
        #build bar glyphs based on graphic parameter
        verts = self._make_bars(self.orientation, visual['position'], 
                   visual['width'], visual['floor'], visual['length'])
        self._paths = [mpath.Path(xy, closed=True) for xy in verts]
        self.set_edgecolors('k')
        self.set_facecolors(visual['facecolors'])
        
    def draw(self, renderer, *args, **kwargs):
        view = self.data.view()
        visual = utils.convert_transforms(view, self.transforms)  
        self.assemble(visual)
        super().draw(renderer, *args, **kwargs)
        return      
\end{minted}
The \mintinline{python}{draw} method identical to the ones above, but here the visual transformations are factored out into a separate function. The \mintinline{python}{assemble} function sets some defaults, constructs bars, and sets their edge color to black. The \mintinline{python}{_make_bars} function is somewhat factored out because this is an operation that may be used by other bar making functions that may not be able to make use of bars assemble or draw. 

\begin{figure}[H]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/bar_stacked.png}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{figures/code/bar_grouped.png}
    \end{subfigure}
    \caption{Penguin count disaggregated by island and species}
    \label{fig:code_bar_multi}
\end{figure}

For example, the \mintinline{python}{MultiBar} artist that makes figure~\ref{fig:code_bar_multi} reuses \mintinline{python}{_make_bars} but does not reuse the assemble function because the composition of elements forces fundemental differences in glyph construction. As demonstrated in the \mintinline{python}{init}, the composite bar chart has orientation and whether it is stacked or not. While the stacked bar chart and the grouped bar chart could be seperate artists, as demonstrated they share so much overlapping code that it is far less redundant to implement them together.  \note{looking at the mess that is this code, I'm a) not convinced these should be combined b) no longer convinced this provides anything over just bar if it isn't rewritten to use bar more}

\begin{minted}{python}
class MultiBar(mcollections.Collection):
    def __init__(self, data, transforms, *args, **kwargs):
        #set the orientation of the graphic  
        self.orientation = kwargs.pop('orientation', 'v')
        # set how the bar glyphs are put together to create the graphic
        self.stacked = kwargs.pop('stacked', False)     
        # rest is same as other artist __init__s

        #this needs to be factored out but just want to finish now
        self.width = kwargs.pop('width', .8)
       
    def assemble(self, visual, view):
        (groups, gencoder) = self.transforms['length']
        ngroups = len(np.atleast_1d(groups))
        visual['floor'] = visual.get('floor', np.empty(len(view[groups[0]])))
        visual['facecolors'] = visual.get('facecolors', 'C0')
        # make equal width stacked columns 
        if 'width' not in visual and self.stacked:
            visual['width'] = itertools.repeat(self.width)

        # make equal with groups
        if not self.stacked:
            visual['width'] = itertools.repeat(self.width/ngroups)
            offset = (np.arange(ngroups) /ngroups) * self.width
        else:
            offset = itertools.repeat(0)
        
        # make the bars and arrange them 
        verts = []
        for group, off in zip(groups, offset):
            verts.extend(Bar._make_bars(self.orientation, visual['position'] + off, 
                          visual['width'], visual['floor'], view[group]))
            if self.stacked: #add stacked bar to previous bar
                visual['floor'] += view[group]
          
        # convert lengths after all calculations are made and reorient if needed
        # here or in transform machinery?
        if self.orientation in {'v', 'vertical'}:
            tverts = [[(x, gencoder(y)) for (x, y) in vert] 
                            for vert in verts]
        elif self.orientation in {'h', 'horizontal'}:
            tverts = [[(gencoder(x), y) for (x, y) in vert] 
                            for vert in verts]
        self._paths = [mpath.Path(xy, closed=True) for xy in tverts]
        #flatted columns of colors to match list of bars
        self.set_facecolor(list(itertools.chain.from_iterable(visual['facecolors'])))
        self.set_edgecolors('k')
        
    def draw(self, renderer, *args, **kwargs):
        view = self.data.view()
        #exclude converting the group visual length, special cased in assemble
        visual = utils.convert_transforms(view, self.transforms, exclude=['length'])
        # pass in view because nu is not distributable so may need to apply it 
        # after visual assembly
        self.assemble(visual, view)
        super().draw(renderer, *args, **kwargs)
        return      
\end{minted}

In the \mintinline{python}{__draw__}, a utility function is used for conversions, but the length transforms are held until after assembly because the length is computed by adding the current length to the previous and many transforms are not distributable such that $\nu(x_0 + x_1 + x_2) = \nu(x_0) + \nu(x_1) + \nu(x_2)$. Inside \mintinline{python}{assemble}, the glyphs are either shifted vertically (\texttt{stacked}) or horizontally (\texttt{grouped}) such that the positions are recorded and added to with the next group. This function allows multiple columns to be mapped to a visual parameter, but it must be equal numbers of columns
\begin{minted}{python}
{'position': ('island', lambda x: {'Biscoe':0, 'Dream':1, 'Torgersen':2}[x]),
 'length':(['Adelie', 'Chinstrap', 'Gentoo'], lambda x: x),
 'facecolors': (['Adelie_s', 'Chinstrap_s', 'Gentoo_s'], 
        color.Categorical({'Adelie':'#FF8C00',
                           'Gentoo':'#159090', 
                           'Chinstrap':'#A034F0'}))}
\end{minted}
such as in this example where for each column contributing to a segment of the bar there is a corresponding column of colors for this segment. The reason the multibar can work with such a trasnformer is because it is relying on the data model to do most of the bookkeeping of which values get mapped to which bars. This also yields a much simpler function call to the artist

\begin{minted}{python}
fig, ax = plt.subplots()
artist = bar.MultiBar(table, trans, orientation='h', stacked=True)
ax.add_artist(artist)
\end{minted}

where \mintinline{python}{trans} is the same dictionary for both stacked and grouped version, as is the \mintinline{python}{DataFrameSection} object \mintinline{python}{table}. The only difference between the two versions is the \texttt{stacked} flag, and the only difference between figures~\ref{fig:code_bar_simple} is the \texttt{orientation} argument. By decomposing the architecture into data, visual encoding, and assembly steps, we are able to build components that are more flexible and also more self contained than the existing code base. 


\note{This API may want to be redesigned such that there's a way to clearly couple the columns when doing multindex broadcasting}
\end{document}